package archimate.jet;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.Properties;

import org.eclipse.core.resources.IContainer;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourceAttributes;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.emf.codegen.jet.JETEmitter;
import org.eclipse.emf.codegen.jet.JETException;
import org.eclipse.emf.codegen.util.CodeGenUtil;
import org.eclipse.swt.widgets.Display;
import org.eclipse.ui.IWorkbenchPage;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.ide.IDE;
import org.eclipse.ui.wizards.newresource.BasicNewResourceWizard;

import archimate.Activator;
import archimate.templates.*;

public class JETEngine {
	
	private Config config;

	public JETEngine(Config config) {
		this.config = config;
	}
	
	public void handleSourceFile() throws CoreException, JETException{
		String content = "";
		content = generate(new NullProgressMonitor());
		IFile file = null;
		file = save(new NullProgressMonitor(), content.getBytes());
		selectAndReveal(file);
//		openResource(file);
	}

	/**
	 * Invokes the JET template specified in the <code>Config</code> with the
	 * model specified in the <code>Config</code> and returns the generated text
	 * as a String.
	 * <p>
	 * This implementation uses a <code>JETEmitter</code> to translate the
	 * template to a Java implementation class. The translated class is created
	 * in a hidden project called <code>.JETEmitters</code>.
	 * <p>
	 * In order to be able to compile the translated template implementation
	 * class, the classes used by the model specified in the <code>Config</code>
	 * must be available in the classpath. For this reason, this method sets the
	 * first runtime library of the plugin specified in the <code>Config</code>
	 * as a classpath variable to the <code>.JETEmitters</code> project.
	 * 
	 * @param monitor
	 *            the progress monitor to use. May be <code>null</code>.
	 * @return the source code text generated by the JET template
	 * @throws CoreException
	 */
	protected String generate(IProgressMonitor monitor) throws CoreException {
		monitor = createIfNull(monitor);

		JETEmitter emitter = new JETEmitter(config.getTemplateFullUri(),
				getClass().getClassLoader());
		try {
			emitter.addVariable(config.getClasspathVariable(), config
					.getPluginId());
		} catch (JETException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		IProgressMonitor sub = new SubProgressMonitor(monitor, 1);
		String result = null;
		try {
			result = emitter.generate(sub, new Object[] { config.getModel() });
		} catch (JETException e) {
			// TODO Auto-generated catch block
			System.out.println(e.getMessage());
			e.printStackTrace();
		}
		monitor.worked(1);
		return result;
	}

	protected void selectAndReveal(IResource newResource) {
		BasicNewResourceWizard.selectAndReveal(newResource,
				archimate.actions.ArchiMateAction.getWindow());
	}

	protected void openResource(final IResource resource) {
		if (resource.getType() == IResource.FILE) {
			final IWorkbenchPage activePage = archimate.actions.ArchiMateAction
					.getWindow().getActivePage();
			if (activePage != null) {
				final Display display = archimate.actions.ArchiMateAction
						.getWindow().getShell().getDisplay();
				if (display != null) {
					display.asyncExec(new Runnable() {
						public void run() {
							try {
								IDE.openEditor(activePage, (IFile) resource,
										true);
							} catch (PartInitException e) {
								Activator.log(e);
							}
						}
					});
				}
			}
		}
	}

	/**
	 * Saves the specified contents to a location specified by the
	 * <code>Config</code> settings. The location of the file to save is found
	 * by finding or creating the container (folder) for the <code>Config</code>
	 * 's package in the <code>Config</code>'s target folder. The name of the
	 * file to save is the <code>Config</code>'s target file.
	 * 
	 * @param monitor
	 *            the progress monitor to use. May be <code>null</code>.
	 * @param contents
	 *            the byte contents of the file to save
	 * @throws CoreException
	 * @throws JETException
	 */
	public IFile save(IProgressMonitor monitor, byte[] contents)
			throws CoreException, JETException {
		monitor = createIfNull(monitor);

		IContainer container = findOrCreateContainer(monitor, config
				.getTargetFolder(), config.getPackageName());
		if (container == null) {
			throw new JETException(
					"Cound not find or create container for package "
							+ config.getPackageName() + " in "
							+ config.getTargetFolder());
		}
		IFile targetFile = container.getFile(new Path(config.getTargetFile()));
		IFile result = getWritableTargetFile(targetFile, container, config
				.getTargetFile());

		InputStream newContents = new ByteArrayInputStream(contents);
		if (result.exists()) {
			result.setContents(newContents, true, true, new SubProgressMonitor(
					monitor, 1));
		} else {
			result
					.create(newContents, true, new SubProgressMonitor(monitor,
							1));
		}
		return result;
	}

	public IContainer findOrCreateContainer(IProgressMonitor progressMonitor,
			String targetDirectory, String packageName) throws CoreException {

		IPath outputPath = new Path(targetDirectory + "/"
				+ packageName.replace('.', '/'));
		progressMonitor.beginTask("", 4);

		IProgressMonitor sub = new SubProgressMonitor(progressMonitor, 1);
		IPath localLocation = null; // use default
		IContainer container = CodeGenUtil.EclipseUtil.findOrCreateContainer(
				outputPath, true, localLocation, sub);
		return container;
	}

	/**
	 * Returns a <code>IFile</code> that can be written to. If the specified
	 * file is read-write, it is returned unchanged. If the specified file is
	 * read-only and {@link Config#isForceOverwrite()}returns <code>true</code>,
	 * the file is made writable, otherwise a new file is returned in the
	 * specified container with filename <code>"." + fileName + ".new"</code>.
	 * 
	 * @param container
	 *            container to create the new file in if the specified file
	 *            cannot be made writable
	 * @param targetFile
	 *            the file to make writable
	 * @param fileName
	 *            used to create a new file name if the specified file cannot be
	 *            made writable
	 * @return a <code>IFile</code> that can be written to
	 * @throws CoreException
	 */
	private IFile getWritableTargetFile(IFile targetFile, IContainer container,
			String fileName) throws CoreException {
		boolean forceOverwrite = true;
		if (targetFile.isReadOnly()) {
			if (forceOverwrite) {
				ResourceAttributes attributes = new ResourceAttributes();
				attributes.setReadOnly(false);
				((IResource) targetFile).setResourceAttributes(attributes);
			} else {
				targetFile = container
						.getFile(new Path("." + fileName + ".new"));
			}
		}
		return targetFile;
	}

	/**
	 * Returns a non-null progress monitor.
	 * 
	 * @param monitor
	 *            an existing progress monitor
	 * @return a new <code>NullProgressMonitor</code> if the specified monitor
	 *         is <code>null</code>, or the existing monitor otherwise
	 */
	private IProgressMonitor createIfNull(IProgressMonitor monitor) {
		if (monitor == null) {
			return new NullProgressMonitor();
		}
		return monitor;
	}
}
